/// <reference types="node" />

import { ChildProcess } from 'child_process';
import { Cluster } from 'ioredis';
import { ClusterOptions } from 'ioredis';
import { EventEmitter } from 'events';
import { Pipeline } from 'ioredis';
import { Redis } from 'ioredis';
import { RedisOptions as RedisOptions_2 } from 'ioredis';

export declare interface AddChildrenOpts {
    multi: Pipeline;
    nodes: FlowJob[];
    parent: {
        parentOpts: {
            id: string;
            queue: string;
        };
        parentDependenciesKey: string;
    };
    queuesOpts?: FlowQueuesOpts;
}

export declare interface AddNodeOpts {
    multi: Pipeline;
    node: FlowJob;
    parent?: {
        parentOpts: {
            id: string;
            queue: string;
        };
        parentDependenciesKey: string;
    };
    /**
     * Queues options that will be applied in each node depending on queue name presence.
     */
    queuesOpts?: FlowQueuesOpts;
}

export declare interface AdvancedOptions {
    /**
     * A set of custom backoff strategies keyed by name.
     */
    backoffStrategies?: {};
}

export declare function array2obj(arr: string[]): Record<string, string>;

export declare const asyncSend: (proc: procSendLike, msg: any) => Promise<void>;

export declare type BackoffFunction = (attemptsMade?: number, err?: Error, job?: Job) => number;

/**
 * Settings for backing off failed jobs.
 *
 * @see {@link https://docs.bullmq.io/guide/retrying-failing-jobs}
 */
export declare interface BackoffOptions {
    /**
     * Name of the backoff strategy.
     */
    type: string;
    /**
     * Delay in milliseconds.
     */
    delay?: number;
}

export declare class Backoffs {
    static builtinStrategies: BuiltInStrategies;
    static normalize(backoff: number | BackoffOptions): BackoffOptions;
    static calculate(backoff: BackoffOptions, attemptsMade: number, customStrategies: Strategies, err: Error, job: Job): number;
}

declare interface BuiltInStrategies {
    [index: string]: (delay: number) => BackoffFunction;
}

export declare type BulkJobOptions = Omit<JobsOptions, 'repeat'>;

export declare enum ChildCommand {
    Init = 0,
    Start = 1,
    Stop = 2
}

export declare interface ChildMessage {
    cmd: ParentCommand;
    value?: any;
    err?: Error;
}

export declare class ChildPool {
    private masterFile;
    retained: {
        [key: number]: ChildProcessExt;
    };
    free: {
        [key: string]: ChildProcessExt[];
    };
    constructor(masterFile?: string);
    retain(processFile: string): Promise<ChildProcessExt>;
    release(child: ChildProcessExt): void;
    remove(child: ChildProcessExt): void;
    kill(child: ChildProcess, signal?: 'SIGTERM' | 'SIGKILL'): Promise<void>;
    clean(): Promise<void>;
    getFree(id: string): ChildProcessExt[];
    getAllFree(): ChildProcessExt[];
}

export declare interface ChildProcessExt extends ChildProcess {
    processFile?: string;
}

export declare const childSend: (proc: NodeJS.Process, msg: ChildMessage) => Promise<void>;

export declare const clientCommandMessageReg: RegExp;

export declare enum ClientType {
    blocking = "blocking",
    normal = "normal"
}

export declare interface Command {
    name: string;
    options: {
        numberOfKeys: number;
        lua: string;
    };
}

export declare type ConnectionOptions = RedisOptions | Redis | Cluster;

export declare function delay(ms: number): Promise<void>;

export declare const DELAY_TIME_1 = 100;

export declare const DELAY_TIME_5 = 5000;

export declare interface DependenciesOpts {
    processed?: {
        cursor?: number;
        count?: number;
    };
    unprocessed?: {
        cursor?: number;
        count?: number;
    };
}

export declare type EntryId = string;

export declare type EntryRaw = [EntryId, string[]];

export declare enum ErrorCode {
    JobNotExist = -1,
    JobLockNotExist = -2,
    JobNotInState = -3,
    JobPendingDependencies = -4,
    ParentJobNotExist = -5
}

export declare const errorObject: {
    [index: string]: any;
};

export declare type FinishedPropValAttribute = 'returnvalue' | 'failedReason';

export declare type FinishedStatus = 'completed' | 'failed';

export declare interface FlowJob {
    name: string;
    queueName: string;
    data?: any;
    prefix?: string;
    opts?: Omit<JobsOptions, 'parent' | 'repeat'>;
    children?: FlowJob[];
}

export declare interface FlowOpts {
    /**
     * Map of options for Queue classes.
     */
    queuesOptions: FlowQueuesOpts;
}

/**
 * This class allows to add jobs with dependencies between them in such
 * a way that it is possible to build complex flows.
 * Note: A flow is a tree-like structure of jobs that depend on each other.
 * Whenever the children of a given parent are completed, the parent
 * will be processed, being able to access the children's result data.
 * All Jobs can be in different queues, either children or parents,
 */
export declare class FlowProducer extends EventEmitter {
    opts: QueueBaseOptions;
    toKey: (name: string, type: string) => string;
    keys: KeysMap;
    closing: Promise<void>;
    queueKeys: QueueKeys;
    protected connection: RedisConnection;
    constructor(opts?: QueueBaseOptions);
    /**
     * Adds a flow.
     *
     * This call would be atomic, either it fails and no jobs will
     * be added to the queues, or it succeeds and all jobs will be added.
     *
     * @param flow - an object with a tree-like structure where children jobs
     * will be processed before their parents.
     * @param opts - options that will be applied to the flow object.
     */
    add(flow: FlowJob, opts?: FlowOpts): Promise<JobNode>;
    /**
     * Get a flow.
     *
     * @param opts - an object with options for getting a JobNode.
     */
    getFlow(opts: NodeOpts): Promise<JobNode>;
    get client(): Promise<RedisClient>;
    /**
     * Adds multiple flows.
     *
     * A flow is a tree-like structure of jobs that depend on each other.
     * Whenever the children of a given parent are completed, the parent
     * will be processed, being able to access the children's result data.
     *
     * All Jobs can be in different queues, either children or parents,
     * however this call would be atomic, either it fails and no jobs will
     * be added to the queues, or it succeeds and all jobs will be added.
     *
     * @param flows - an array of objects with a tree-like structure where children jobs
     * will be processed before their parents.
     */
    addBulk(flows: FlowJob[]): Promise<JobNode[]>;
    /**
     * Add a node (job) of a flow to the queue. This method will recursively
     * add all its children as well. Note that a given job can potentially be
     * a parent and a child job at the same time depending on where it is located
     * in the tree hierarchy.
     *
     * @param multi - ioredis pipeline
     * @param node - the node representing a job to be added to some queue
     * @param parent - parent data sent to children to create the "links" to their parent
     * @returns
     */
    private addNode;
    /**
     * Adds nodes (jobs) of multiple flows to the queue. This method will recursively
     * add all its children as well. Note that a given job can potentially be
     * a parent and a child job at the same time depending on where it is located
     * in the tree hierarchy.
     *
     * @param multi - ioredis pipeline
     * @param nodes - the nodes representing jobs to be added to some queue
     * @returns
     */
    private addNodes;
    private getNode;
    private addChildren;
    private getChildren;
    /**
     * Helper factory method that creates a queue-like object
     * required to create jobs in any queue.
     *
     * @param node -
     * @param queueKeys -
     * @returns
     */
    private queueFromNode;
    close(): Promise<void>;
    disconnect(): Promise<void>;
}

export declare type FlowQueuesOpts = Record<string, Omit<QueueOptions, 'connection' | 'prefix'>>;

export declare interface GetNextJobOptions {
    block?: boolean;
}

export declare function getParentKey(opts: {
    id: string;
    queue: string;
}): string;

export declare interface IConnection extends EventEmitter {
    waitUntilReady(): Promise<boolean>;
    client: Promise<RedisClient>;
}

export declare function isEmpty(obj: object): boolean;

export declare function isNotConnectionError(error: Error): boolean;

export declare function isRedisInstance(obj: any): boolean;

export declare class Job<DataType = any, ReturnType = any, NameType extends string = string> {
    protected queue: MinimalQueue;
    /**
     * The name of the Job
     */
    name: NameType;
    /**
     * The payload for this job.
     */
    data: DataType;
    /**
     * The options object for this job.
     */
    opts: JobsOptions;
    id?: string;
    /**
     * The progress a job has performed so far.
     * @defaultValue 0
     */
    progress: number | object;
    /**
     * The value returned by the processor when processing this job.
     * @defaultValue null
     */
    returnvalue: ReturnType;
    /**
     * Stacktrace for the error (for failed jobs).
     * @defaultValue null
     */
    stacktrace: string[];
    /**
     * Timestamp when the job was created (unless overridden with job options).
     */
    timestamp: number;
    /**
     * Number of attempts after the job has failed.
     * @defaultValue 0
     */
    attemptsMade: number;
    /**
     * Reason for failing.
     */
    failedReason: string;
    /**
     * Timestamp for when the job finished (completed or failed).
     */
    finishedOn?: number;
    /**
     * Timestamp for when the job was processed.
     */
    processedOn?: number;
    /**
     * Fully qualified key (including the queue prefix) pointing to the parent of this job.
     */
    parentKey?: string;
    /**
     * Object that contains parentId (id) and parent queueKey.
     */
    parent?: ParentKeys;
    protected toKey: (type: string) => string;
    private discarded;
    constructor(queue: MinimalQueue, 
    /**
     * The name of the Job
     */
    name: NameType, 
    /**
     * The payload for this job.
     */
    data: DataType, 
    /**
     * The options object for this job.
     */
    opts?: JobsOptions, id?: string);
    /**
     * Creates a new job and adds it to the queue.
     *
     * @param queue - the queue where to add the job.
     * @param name - the name of the job.
     * @param data - the payload of the job.
     * @param opts - the options bag for this job.
     * @returns
     */
    static create<T = any, R = any, N extends string = string>(queue: MinimalQueue, name: N, data: T, opts?: JobsOptions): Promise<Job<T, R, N>>;
    /**
     * Creates a bulk of jobs and adds them atomically to the given queue.
     *
     * @param queue -the queue were to add the jobs.
     * @param jobs - an array of jobs to be added to the queue.
     * @returns
     */
    static createBulk<T = any, R = any, N extends string = string>(queue: MinimalQueue, jobs: {
        name: N;
        data: T;
        opts?: BulkJobOptions;
    }[]): Promise<Job<T, R, N>[]>;
    /**
     * Instantiates a Job from a JobJsonRaw object (coming from a deserialized JSON object)
     *
     * @param queue - the queue where the job belongs to.
     * @param json - the plain object containing the job.
     * @param jobId - an optional job id (overrides the id coming from the JSON object)
     * @returns
     */
    static fromJSON<T = any, R = any, N extends string = string>(queue: MinimalQueue, json: JobJsonRaw, jobId?: string): Job<T, R, N>;
    /**
     * Fetches a Job from the queue given the passed job id.
     *
     * @param queue - the queue where the job belongs to.
     * @param jobId - the job id.
     * @returns
     */
    static fromId<T = any, R = any, N extends string = string>(queue: MinimalQueue, jobId: string): Promise<Job<T, R, N> | undefined>;
    toJSON(): Omit<this, 'queue'>;
    /**
     * Prepares a job to be serialized for storage in Redis.
     * @returns
     */
    asJSON(): JobJson;
    /**
     * Prepares a job to be passed to Sandbox.
     * @returns
     */
    asJSONSandbox(): JobJsonSandbox;
    /**
     * Updates a job's data
     *
     * @param data - the data that will replace the current jobs data.
     */
    update(data: DataType): Promise<void>;
    /**
     * Updates a job's progress
     *
     * @param progress - number or object to be saved as progress.
     */
    updateProgress(progress: number | object): Promise<void>;
    /**
     * Logs one row of log data.
     *
     * @param logRow - string with log data to be logged.
     */
    log(logRow: string): Promise<number>;
    /**
     * Completely remove the job from the queue.
     * Note, this call will throw an exception if the job
     * is being processed when the call is performed.
     */
    remove(): Promise<void>;
    /**
     * Extend the lock for this job.
     *
     * @param token - unique token for the lock
     * @param duration - lock duration in milliseconds
     */
    extendLock(token: string, duration: number): Promise<number>;
    /**
     * Moves a job to the completed queue.
     * Returned job to be used with Queue.prototype.nextJobFromJobData.
     *
     * @param returnValue - The jobs success message.
     * @param token - Worker token used to acquire completed job.
     * @param fetchNext - True when wanting to fetch the next job.
     * @returns Returns the jobData of the next job in the waiting queue.
     */
    moveToCompleted(returnValue: ReturnType, token: string, fetchNext?: boolean): Promise<JobData | []>;
    /**
     * Moves a job to the failed queue.
     *
     * @param err - the jobs error message.
     * @param token - token to check job is locked by current worker
     * @param fetchNext - true when wanting to fetch the next job
     * @returns void
     */
    moveToFailed<E extends Error>(err: E, token: string, fetchNext?: boolean): Promise<void>;
    /**
     * @returns true if the job has completed.
     */
    isCompleted(): Promise<boolean>;
    /**
     * @returns true if the job has failed.
     */
    isFailed(): Promise<boolean>;
    /**
     * @returns true if the job is delayed.
     */
    isDelayed(): Promise<boolean>;
    /**
     * @returns true if the job is waiting for children.
     */
    isWaitingChildren(): Promise<boolean>;
    /**
     * @returns true of the job is active.
     */
    isActive(): Promise<boolean>;
    /**
     * @returns true if the job is waiting.
     */
    isWaiting(): Promise<boolean>;
    /**
     * @returns the queue name this job belongs to.
     */
    get queueName(): string;
    get prefix(): string;
    /**
     * Get current state.
     *
     * @returns Returns one of these values:
     * 'completed', 'failed', 'delayed', 'active', 'waiting', 'waiting-children', 'unknown'.
     */
    getState(): Promise<JobState | 'unknown'>;
    /**
     * Change delay of a delayed job.
     *
     * @param delay - milliseconds to be added to current time.
     * @returns void
     */
    changeDelay(delay: number): Promise<void>;
    /**
     * Get this jobs children result values if any.
     *
     * @returns Object mapping children job keys with their values.
     */
    getChildrenValues<CT = any>(): Promise<{
        [jobKey: string]: CT;
    }>;
    /**
     * Get children job keys if this job is a parent and has children.
     *
     * @returns dependencies separated by processed and unprocessed.
     */
    getDependencies(opts?: DependenciesOpts): Promise<{
        nextProcessedCursor?: number;
        processed?: Record<string, any>;
        nextUnprocessedCursor?: number;
        unprocessed?: string[];
    }>;
    /**
     * Get children job counts if this job is a parent and has children.
     *
     * @returns dependencies count separated by processed and unprocessed.
     */
    getDependenciesCount(opts?: {
        processed?: boolean;
        unprocessed?: boolean;
    }): Promise<{
        processed?: number;
        unprocessed?: number;
    }>;
    /**
     * Returns a promise the resolves when the job has completed (containing the return value of the job),
     * or rejects when the job has failed (containing the failedReason).
     *
     * @param queueEvents - Instance of QueueEvents.
     * @param ttl - Time in milliseconds to wait for job to finish before timing out.
     */
    waitUntilFinished(queueEvents: QueueEvents, ttl?: number): Promise<ReturnType>;
    /**
     * Moves the job to the delay set.
     *
     * @param timestamp - timestamp where the job should be moved back to "wait"
     * @returns
     */
    moveToDelayed(timestamp: number): Promise<void>;
    /**
     * Moves the job to the waiting-children set.
     *
     * @param token - Token to check job is locked by current worker
     * @param opts - The options bag for moving a job to waiting-children.
     * @returns true if the job was moved
     */
    moveToWaitingChildren(token: string, opts?: MoveToChildrenOpts): Promise<boolean | Error>;
    /**
     * Promotes a delayed job so that it starts to be processed as soon as possible.
     */
    promote(): Promise<void>;
    /**
     * Attempts to retry the job. Only a job that has failed or completed can be retried.
     *
     * @param state - completed / failed
     * @returns If resolved and return code is 1, then the queue emits a waiting event
     * otherwise the operation was not a success and throw the corresponding error. If the promise
     * rejects, it indicates that the script failed to execute
     */
    retry(state?: 'completed' | 'failed'): Promise<void>;
    /**
     * Marks a job to not be retried if it fails (even if attempts has been configured)
     */
    discard(): void;
    private isInZSet;
    private isInList;
    /**
     * Adds the job to Redis.
     *
     * @param client -
     * @param parentOpts -
     * @returns
     */
    addJob(client: RedisClient, parentOpts?: ParentOpts): Promise<string>;
    private saveStacktrace;
}

export declare type JobData = [JobJsonRaw | number, string?];

export declare function jobIdForGroup(jobOpts: JobsOptions, data: any, queueOpts: QueueOptions): string;

export declare interface JobJson {
    id: string;
    name: string;
    data: string;
    opts: JobsOptions;
    progress: number | object;
    attemptsMade: number;
    finishedOn?: number;
    processedOn?: number;
    timestamp: number;
    failedReason: string;
    stacktrace: string;
    returnvalue: string;
    parentKey?: string;
}

export declare interface JobJsonRaw {
    id: string;
    name: string;
    data: string;
    opts: string;
    progress: string;
    attemptsMade: string;
    finishedOn?: string;
    processedOn?: string;
    timestamp: string;
    failedReason: string;
    stacktrace: string[];
    returnvalue: string;
    parentKey?: string;
    parent?: string;
}

export declare type JobJsonSandbox = JobJson & {
    queueName: string;
    parent?: ParentKeys;
    prefix: string;
};

export declare interface JobNode {
    job: Job;
    children?: JobNode[];
}

export declare interface JobsOptions {
    /**
     * Timestamp when the job was created. Defaults to `Date.now()`.
     */
    timestamp?: number;
    /**
     * Ranges from 1 (highest priority) to MAX_INT (lowest priority). Note that
     * using priorities has a slight impact on performance,
     * so do not use it if not required.
     */
    priority?: number;
    /**
     * An amount of milliseconds to wait until this job can be processed.
     * Note that for accurate delays, worker and producers
     * should have their clocks synchronized.
     * @defaultValue 0
     */
    delay?: number;
    /**
     * The total number of attempts to try the job until it completes.
     * @defaultValue 0
     */
    attempts?: number;
    /**
     * Repeat this job, for example based on a `cron` schedule.
     */
    repeat?: RepeatOptions;
    /**
     * Rate limiter key to use if rate limiter enabled.
     *
     * @see {@link https://docs.bullmq.io/guide/rate-limiting}
     */
    rateLimiterKey?: string;
    /**
     * Backoff setting for automatic retries if the job fails
     */
    backoff?: number | BackoffOptions;
    /**
     * If true, adds the job to the right of the queue instead of the left (default false)
     *
     * @see {@link https://docs.bullmq.io/guide/jobs/lifo}
     */
    lifo?: boolean;
    /**
     * The number of milliseconds after which the job should be
     * fail with a timeout error.
     */
    timeout?: number;
    /**
     * Override the job ID - by default, the job ID is a unique
     * integer, but you can use this setting to override it.
     * If you use this option, it is up to you to ensure the
     * jobId is unique. If you attempt to add a job with an id that
     * already exists, it will not be added.
     */
    jobId?: string;
    /**
     * If true, removes the job when it successfully completes
     * When given an number, it specifies the maximum amount of
     * jobs to keep, or you can provide an object specifying max
     * age and/or count to keep.
     * Default behavior is to keep the job in the completed set.
     */
    removeOnComplete?: boolean | number | KeepJobs;
    /**
     * If true, removes the job when it fails after all attempts.
     * When given an number, it specifies the maximum amount of
     * jobs to keep, or you can provide an object specifying max
     * age and/or count to keep.
     */
    removeOnFail?: boolean | number | KeepJobs;
    /**
     * Limits the amount of stack trace lines that will be recorded in the stacktrace.
     */
    stackTraceLimit?: number;
    /**
     *
     */
    parent?: {
        id: string;
        queue: string;
    };
    /**
     * Internal property used by repeatable jobs.
     */
    prevMillis?: number;
    /**
     * Limits the size in bytes of the job's data payload (as a JSON serialized string).
     */
    sizeLimit?: number;
}

export declare type JobState = FinishedStatus | 'active' | 'delayed' | 'waiting' | 'waiting-children';

export declare type JobType = JobState | 'paused' | 'repeat' | 'wait';

/**
 * KeepJobs
 *
 * Specify which jobs to keep after finishing. If both age and count are
 * specified, then the jobs kept will be the ones that satisfies both
 * properties.
 */
export declare interface KeepJobs {
    /**
     * Maximum age in seconds for job to be kept.
     */
    age?: number;
    /**
     * Maximum count of jobs to be kept.
     */
    count?: number;
}

declare type KeysMap = {
    [index in string]: string;
};

/**
 * Checks the size of string for ascii/non-ascii characters
 * @see https://stackoverflow.com/a/23318053/1347170
 * @param str -
 */
export declare function lengthInUtf8Bytes(str: string): number;

export declare type MinimalQueue = Pick<QueueBase, 'name' | 'client' | 'toKey' | 'keys' | 'opts' | 'closing' | 'waitUntilReady' | 'removeListener' | 'emit' | 'on' | 'redisVersion'>;

export declare interface MoveToChildrenOpts {
    timestamp?: number;
    child?: {
        id: string;
        queue: string;
    };
}

export declare interface NodeOpts {
    /**
     * Root job queue name.
     */
    queueName: string;
    /**
     * Prefix included in job key.
     */
    prefix?: string;
    /**
     * Root job id.
     */
    id: string;
    /**
     * Maximum depth or levels to visit in the tree.
     */
    depth?: number;
    /**
     * Maximum quantity of children per type (processed, unprocessed).
     */
    maxChildren?: number;
}

export declare interface ObliterateOpts {
    /**
     * Use force = true to force obliteration even with active jobs in the queue
     * @defaultValue false
     */
    force?: boolean;
    /**
     * Use count with the maximum number of deleted keys per iteration
     * @defaultValue 1000
     */
    count?: number;
}

/**
 * Describes the parent for a Job.
 */
export declare interface Parent<T> {
    name: string;
    prefix?: string;
    queue?: string;
    data?: T;
    opts?: JobsOptions;
}

export declare enum ParentCommand {
    InitFailed = 0,
    InitCompleted = 1,
    Completed = 2,
    Failed = 3,
    Error = 4,
    Progress = 5,
    Log = 6
}

export declare interface ParentKeys {
    id: string;
    queueKey: string;
}

export declare interface ParentMessage {
    cmd: ChildCommand;
    value?: any;
    err?: Error;
    job?: JobJson;
}

export declare type ParentOpts = {
    waitChildrenKey?: string;
    parentDependenciesKey?: string;
    parentKey?: string;
};

export declare const parentSend: (child: ChildProcess, msg: ParentMessage) => Promise<void>;

/**
 * An async function that receives `Job`s and handles them.
 */
export declare type Processor<T = any, R = any, N extends string = string> = (job: Job<T, R, N>, token?: string) => Promise<R>;

declare interface procSendLike {
    send?(message: any, sendHandle?: any, options?: {
        swallowErrors?: boolean;
    }, callback?: (error: Error) => void): boolean;
}

/**
 * Queue
 *
 * This class provides methods to add jobs to a queue and some othe high-level
 * administration such as pausing or deleting queues.
 *
 */
export declare class Queue<DataType = any, ResultType = any, NameType extends string = string> extends QueueGetters<DataType, ResultType, NameType> {
    token: string;
    jobsOpts: JobsOptions;
    limiter: {
        groupKey: string;
    };
    private _repeat;
    constructor(name: string, opts?: QueueOptions, Connection?: typeof RedisConnection);
    emit<U extends keyof QueueListener<DataType, ResultType, NameType>>(event: U, ...args: Parameters<QueueListener<DataType, ResultType, NameType>[U]>): boolean;
    off<U extends keyof QueueListener<DataType, ResultType, NameType>>(eventName: U, listener: QueueListener<DataType, ResultType, NameType>[U]): this;
    on<U extends keyof QueueListener<DataType, ResultType, NameType>>(event: U, listener: QueueListener<DataType, ResultType, NameType>[U]): this;
    once<U extends keyof QueueListener<DataType, ResultType, NameType>>(event: U, listener: QueueListener<DataType, ResultType, NameType>[U]): this;
    /**
     * Returns this instance current default job options.
     */
    get defaultJobOptions(): JobsOptions;
    get repeat(): Promise<Repeat>;
    /**
     * Adds a new job to the queue.
     *
     * @param name - Name of the job to be added to the queue,.
     * @param data - Arbitrary data to append to the job.
     * @param opts - Job options that affects how the job is going to be processed.
     */
    add(name: NameType, data: DataType, opts?: JobsOptions): Promise<Job<DataType, ResultType, NameType>>;
    /**
     * Adds an array of jobs to the queue.
     *
     * @param jobs - The array of jobs to add to the queue. Each job is defined by 3
     * properties, 'name', 'data' and 'opts'. They follow the same signature as 'Queue.add'.
     */
    addBulk(jobs: {
        name: NameType;
        data: DataType;
        opts?: BulkJobOptions;
    }[]): Promise<Job<DataType, DataType, NameType>[]>;
    /**
     * Pauses the processing of this queue globally.
     *
     * We use an atomic RENAME operation on the wait queue. Since
     * we have blocking calls with BRPOPLPUSH on the wait queue, as long as the queue
     * is renamed to 'paused', no new jobs will be processed (the current ones
     * will run until finalized).
     *
     * Adding jobs requires a LUA script to check first if the paused list exist
     * and in that case it will add it there instead of the wait list.
     */
    pause(): Promise<void>;
    /**
     * Resumes the processing of this queue globally.
     *
     * The method reverses the pause operation by resuming the processing of the
     * queue.
     */
    resume(): Promise<void>;
    /**
     * Returns true if the queue is currently paused.
     */
    isPaused(): Promise<boolean>;
    /**
     * Get all repeatable meta jobs.
     *
     * @param start - Offset of first job to return.
     * @param end - Offset of last job to return.
     * @param asc - Determine the order in which jobs are returned based on their
     * next execution time.
     */
    getRepeatableJobs(start?: number, end?: number, asc?: boolean): Promise<{
        key: string;
        name: string;
        id: string;
        endDate: number;
        tz: string;
        cron: string;
        next: number;
    }[]>;
    removeRepeatable(name: NameType, repeatOpts: RepeatOptions, jobId?: string): Promise<void>;
    removeRepeatableByKey(key: string): Promise<void>;
    /**
     * Removes the given job from the queue as well as all its
     * dependencies.
     *
     * @param jobId - The id of the job to remove
     * @returns 1 if it managed to remove the job or 0 if the job or
     * any of its dependencies was locked.
     */
    remove(jobId: string): Promise<number>;
    /**
     * Drains the queue, i.e., removes all jobs that are waiting
     * or delayed, but not active, completed or failed.
     *
     * @param delayed - Pass true if it should also clean the
     * delayed jobs.
     */
    drain(delayed?: boolean): Promise<void>;
    /**
     * Cleans jobs from a queue. Similar to drain but keeps jobs within a certain
     * grace period.
     *
     * @param grace - The grace period
     * @param limit - Max number of jobs to clean
     * @param type - Default completed - The type of job to clean
     * Possible values are completed, wait, active, paused, delayed, failed. Defaults to completed.
     * @returns Id jobs from the deleted records
     */
    clean(grace: number, limit: number, type?: 'completed' | 'wait' | 'active' | 'paused' | 'delayed' | 'failed'): Promise<string[]>;
    /**
     * Completely destroys the queue and all of its contents irreversibly.
     * This method will the *pause* the queue and requires that there are no
     * active jobs. It is possible to bypass this requirement, i.e. not
     * having active jobs using the "force" option.
     *
     * Note: This operation requires to iterate on all the jobs stored in the queue
     * and can be slow for very large queues.
     *
     * @param opts - Obliterate options.
     */
    obliterate(opts?: ObliterateOpts): Promise<void>;
    /**
     * Retry all the failed jobs.
     *
     * @param opts - contains number to limit how many jobs will be moved to wait status per iteration,
     * state (failed, completed) failed by default or from which timestamp.
     * @returns
     */
    retryJobs(opts?: {
        count?: number;
        state?: FinishedStatus;
        timestamp?: number;
    }): Promise<void>;
    /**
     * Trim the event stream to an approximately maxLength.
     *
     * @param maxLength -
     */
    trimEvents(maxLength: number): Promise<number>;
}

export declare class QueueBase extends EventEmitter {
    readonly name: string;
    opts: QueueBaseOptions;
    toKey: (type: string) => string;
    keys: KeysMap;
    closing: Promise<void>;
    protected connection: RedisConnection;
    constructor(name: string, opts?: QueueBaseOptions, Connection?: typeof RedisConnection);
    get client(): Promise<RedisClient>;
    get redisVersion(): string;
    emit(event: string | symbol, ...args: any[]): boolean;
    waitUntilReady(): Promise<RedisClient>;
    protected base64Name(): string;
    protected clientName(): string;
    close(): Promise<void>;
    disconnect(): Promise<void>;
}

/**
 * Base Queue options
 */
export declare interface QueueBaseOptions {
    /**
     * Options for connecting to a Redis instance.
     */
    connection?: ConnectionOptions;
    /**
     * Specify if the connection is shared.
     */
    sharedConnection?: boolean;
    /**
     * Prefix for all queue keys.
     */
    prefix?: string;
}

/**
 * The QueueEvents class is used for listening to the global events
 * emitted by a given queue.
 *
 * This class requires a dedicated redis connection.
 *
 */
export declare class QueueEvents extends QueueBase {
    private running;
    emit<U extends keyof QueueEventsListener>(event: U, ...args: Parameters<QueueEventsListener[U]>): boolean;
    off<U extends keyof QueueEventsListener>(eventName: U, listener: QueueEventsListener[U]): this;
    on<U extends keyof QueueEventsListener>(event: U, listener: QueueEventsListener[U]): this;
    once<U extends keyof QueueEventsListener>(event: U, listener: QueueEventsListener[U]): this;
    constructor(name: string, { connection, autorun, ...opts }?: QueueEventsOptions, Connection?: typeof RedisConnection);
    run(): Promise<void>;
    private consumeEvents;
    close(): Promise<void>;
}

export declare interface QueueEventsListener {
    /**
     * Listen to 'active' event.
     *
     * This event is triggered when a job enters the 'active' state.
     */
    active: (args: {
        jobId: string;
        prev?: string;
    }, id: string) => void;
    /**
     * Listen to 'added' event.
     *
     * This event is triggered when a job is created.
     */
    added: (args: {
        jobId: string;
        name: string;
        data: string;
        opts: string;
    }, id: string) => void;
    /**
     * Listen to 'cleaned' event.
     *
     * This event is triggered when a cleaned method is triggered.
     */
    cleaned: (args: {
        count: string;
    }, id: string) => void;
    /**
     * Listen to 'completed' event.
     *
     * This event is triggered when a job has successfully completed.
     */
    completed: (args: {
        jobId: string;
        returnvalue: string;
        prev?: string;
    }, id: string) => void;
    /**
     * Listen to 'delayed' event.
     *
     * This event is triggered when a job is delayed.
     */
    delayed: (args: {
        jobId: string;
        delay: number;
    }, id: string) => void;
    /**
     * Listen to 'drained' event.
     *
     * This event is triggered when the queue has drained the waiting list.
     * Note that there could still be delayed jobs waiting their timers to expire
     * and this event will still be triggered as long as the waiting list has emptied.
     */
    drained: (id: string) => void;
    /**
     * Listen to 'error' event.
     *
     * This event is triggered when an exception is thrown.
     */
    error: (args: Error) => void;
    /**
     * Listen to 'failed' event.
     *
     * This event is triggered when a job has thrown an exception.
     */
    failed: (args: {
        jobId: string;
        failedReason: string;
        prev?: string;
    }, id: string) => void;
    /**
     * Listen to 'paused' event.
     *
     * This event is triggered when a queue is paused.
     */
    paused: (args: {}, id: string) => void;
    /**
     * Listen to 'progress' event.
     *
     * This event is triggered when a job updates it progress, i.e. the
     * Job##updateProgress() method is called. This is useful to notify
     * progress or any other data from within a processor to the rest of the
     * world.
     */
    progress: (args: {
        jobId: string;
        data: number | object;
    }, id: string) => void;
    /**
     * Listen to 'removed' event.
     *
     * This event is triggered when a job has been manually
     * removed from the queue.
     */
    removed: (args: {
        jobId: string;
    }, id: string) => void;
    /**
     * Listen to 'resumed' event.
     *
     * This event is triggered when a queue is resumed.
     */
    resumed: (args: {}, id: string) => void;
    /**
     * Listen to 'retries-exhausted' event.
     *
     * This event is triggered when a job has retried the maximum attempts.
     */
    'retries-exhausted': (args: {
        jobId: string;
        attemptsMade: string;
    }, id: string) => void;
    /**
     * Listen to 'stalled' event.
     *
     * This event is triggered when a job has been moved from 'active' back
     * to 'waiting'/'failed' due to the processor not being able to renew
     * the lock on the said job.
     */
    stalled: (args: {
        jobId: string;
    }, id: string) => void;
    /**
     * Listen to 'waiting' event.
     *
     * This event is triggered when a job enters the 'waiting' state.
     */
    waiting: (args: {
        jobId: string;
    }, id: string) => void;
    /**
     * Listen to 'waiting-children' event.
     *
     * This event is triggered when a job enters the 'waiting-children' state.
     */
    'waiting-children': (args: {
        jobId: string;
    }, id: string) => void;
}

/**
 * Options for QueueEvents
 */
export declare interface QueueEventsOptions extends QueueBaseOptions {
    /**
     * Condition to start listening to events at instance creation.
     */
    autorun?: boolean;
    /**
     * Last event Id. If provided it is possible to continue
     * consuming events from a known Id instead of from the last
     * produced event.
     */
    lastEventId?: string;
    /**
     * Timeout for the blocking XREAD call to the events stream.
     */
    blockingTimeout?: number;
}

export declare class QueueGetters<DataType, ResultType, NameType extends string> extends QueueBase {
    getJob(jobId: string): Promise<Job<DataType, ResultType, NameType> | undefined>;
    private commandByType;
    /**
     Returns the number of jobs waiting to be processed.
     */
    count(): Promise<number>;
    /**
     * Job counts by type
     *
     * Queue#getJobCountByTypes('completed') => completed count
     * Queue#getJobCountByTypes('completed,failed') => completed + failed count
     * Queue#getJobCountByTypes('completed', 'failed') => completed + failed count
     * Queue#getJobCountByTypes('completed', 'waiting', 'failed') => completed + waiting + failed count
     */
    getJobCountByTypes(...types: JobType[]): Promise<number>;
    /**
     * Returns the job counts for each type specified or every list/set in the queue by default.
     *
     * @returns An object, key (type) and value (count)
     */
    getJobCounts(...types: JobType[]): Promise<{
        [index: string]: number;
    }>;
    getCompletedCount(): Promise<number>;
    getFailedCount(): Promise<number>;
    getDelayedCount(): Promise<number>;
    getActiveCount(): Promise<number>;
    getWaitingCount(): Promise<number>;
    getWaitingChildrenCount(): Promise<number>;
    getWaiting(start?: number, end?: number): Promise<Job<DataType, ResultType, NameType>[]>;
    getWaitingChildren(start?: number, end?: number): Promise<Job<DataType, ResultType, NameType>[]>;
    getActive(start?: number, end?: number): Promise<Job<DataType, ResultType, NameType>[]>;
    getDelayed(start?: number, end?: number): Promise<Job<DataType, ResultType, NameType>[]>;
    getCompleted(start?: number, end?: number): Promise<Job<DataType, ResultType, NameType>[]>;
    getFailed(start?: number, end?: number): Promise<Job<DataType, ResultType, NameType>[]>;
    getRanges(types: JobType[], start?: number, end?: number, asc?: boolean): Promise<string[]>;
    getJobs(types: JobType[] | JobType, start?: number, end?: number, asc?: boolean): Promise<Job<DataType, ResultType, NameType>[]>;
    getJobLogs(jobId: string, start?: number, end?: number, asc?: boolean): Promise<{
        logs: [string];
        count: number;
    }>;
    /**
     * Get worker list related to the queue.
     *
     * @returns - Returns an array with workers info.
     */
    getWorkers(): Promise<{
        [index: string]: string;
    }[]>;
    /**
     * Get queue schedulers list related to the queue.
     *
     * @returns - Returns an array with queue schedulers info.
     */
    getQueueSchedulers(): Promise<{
        [index: string]: string;
    }[]>;
    private parseClientList;
}

declare class QueueKeys {
    readonly prefix: string;
    constructor(prefix?: string);
    getKeys(name: string): KeysMap;
    toKey(name: string, type: string): string;
    getPrefixedQueueName(name: string): string;
}

export declare interface QueueListener<DataType, ResultType, NameType extends string> {
    /**
     * Listen to 'cleaned' event.
     *
     * This event is triggered when the queue calls clean method.
     */
    cleaned: (jobs: string[], type: string) => void;
    /**
     * Listen to 'error' event.
     *
     * This event is triggered when an error is thrown.
     */
    error: (err: Error) => void;
    /**
     * Listen to 'paused' event.
     *
     * This event is triggered when the queue is paused.
     */
    paused: () => void;
    /**
     * Listen to 'progress' event.
     *
     * This event is triggered when the job updates its progress.
     */
    progress: (job: Job<DataType, ResultType, NameType>, progress: number | object) => void;
    /**
     * Listen to 'removed' event.
     *
     * This event is triggered when a job is removed.
     */
    removed: (job: Job<DataType, ResultType, NameType>) => void;
    /**
     * Listen to 'resumed' event.
     *
     * This event is triggered when the queue is resumed.
     */
    resumed: () => void;
    /**
     * Listen to 'waiting' event.
     *
     * This event is triggered when the queue creates a new job.
     */
    waiting: (job: Job<DataType, ResultType, NameType>) => void;
}

/**
 * Options for the Queue class.
 */
export declare interface QueueOptions extends QueueBaseOptions {
    defaultJobOptions?: JobsOptions;
    /**
     * Options for the rate limiter.
     */
    limiter?: {
        /**
         * Group key to be used by the limiter when
         * limiting by group keys.
         */
        groupKey: string;
    };
    /**
     * Options for the streams used internally in BullMQ.
     */
    streams?: {
        /**
         * Options for the events stream.
         */
        events: {
            /**
             * Max approximated length for streams. Default is 10 000 events.
             */
            maxLen: number;
        };
    };
}

/**
 * This class is just used for some automatic bookkeeping of the queue,
 * such as updating the delay set as well as moving stalled jobs back
 * to the waiting list.
 *
 * Jobs are checked for stallness once every "visibility window" seconds.
 * Jobs are then marked as candidates for being stalled, in the next check,
 * the candidates are marked as stalled and moved to wait.
 * Workers need to clean the candidate list with the jobs that they are working
 * on, failing to update the list results in the job ending being stalled.
 *
 * This class requires a dedicated redis connection, and at least one is needed
 * to be running at a given time, otherwise delays, stalled jobs, retries, repeatable
 * jobs, etc, will not work correctly or at all.
 *
 */
export declare class QueueScheduler extends QueueBase {
    private nextTimestamp;
    private isBlocked;
    private running;
    constructor(name: string, { connection, autorun, ...opts }?: QueueSchedulerOptions);
    emit<U extends keyof QueueSchedulerListener>(event: U, ...args: Parameters<QueueSchedulerListener[U]>): boolean;
    off<U extends keyof QueueSchedulerListener>(eventName: U, listener: QueueSchedulerListener[U]): this;
    on<U extends keyof QueueSchedulerListener>(event: U, listener: QueueSchedulerListener[U]): this;
    once<U extends keyof QueueSchedulerListener>(event: U, listener: QueueSchedulerListener[U]): this;
    run(): Promise<void>;
    isRunning(): boolean;
    private readDelayedData;
    private updateDelaySet;
    private moveStalledJobsToWait;
    protected clientName(): string;
    close(): Promise<void>;
}

export declare interface QueueSchedulerListener {
    /**
     * Listen to 'stalled' event.
     *
     * This event is triggered when a job gets stalled.
     */
    stalled: (jobId: string, prev: string) => void;
    /**
     * Listen to 'failed' event.
     *
     * This event is triggered when a job has thrown an exception.
     */
    failed: (jobId: string, failedReason: Error, prev: string) => void;
}

/**
 * Options for customizing the behaviour of the scheduler.
 *
 * @see {@link https://docs.bullmq.io/guide/jobs/stalled}
 * @see {@link https://docs.bullmq.io/guide/queuescheduler}
 */
export declare interface QueueSchedulerOptions extends QueueBaseOptions {
    /**
     * Condition to start scheduler at instance creation.
     */
    autorun?: boolean;
    /**
     * Amount of times a job can be recovered from a stalled state
     * to the `wait` state. If this is exceeded, the job is moved
     * to `failed`.
     */
    maxStalledCount?: number;
    /**
     * Number of milliseconds between stallness checks.
     */
    stalledInterval?: number;
}

export declare interface RateLimiterOptions {
    /**
     * Max number of jobs to process in the time period
     * specified in `duration`.
     */
    max: number;
    /**
     * Time in milliseconds. During this time, a maximum
     * of `max` jobs will be processed.
     */
    duration: number;
    /**
     * It is possible to define a rate limiter based on group keys,
     * for example you may want to have a rate limiter per customer
     * instead of a global rate limiter for all customers
     *
     * @see {@link https://docs.bullmq.io/guide/rate-limiting}
     */
    groupKey?: string;
    /**
     * This option enables a heuristic so that when a queue is heavily
     * rete limited, it delays the workers so that they do not try
     * to pick jobs when there is no point in doing so.
     * Note: It is not recommended to use this option when using
     * groupKeys unless you have a big amount of workers since
     * you may be delaying workers that could pick jobs in groups that
     * have not been rate limited.
     */
    workerDelay?: boolean;
}

export declare function raw2jobData(raw: any[]): [JobJsonRaw | number, string?] | [];

export declare type RedisClient = Redis | Cluster;

export declare class RedisConnection extends EventEmitter {
    private readonly opts?;
    private readonly shared;
    static minimumVersion: string;
    protected _client: RedisClient;
    private initializing;
    private closing;
    private version;
    private handleClientError;
    constructor(opts?: ConnectionOptions, shared?: boolean);
    private checkOptions;
    private checkUpstashHost;
    /**
     * Waits for a redis client to be ready.
     * @param redis - client
     */
    static waitUntilReady(client: RedisClient): Promise<void>;
    get client(): Promise<RedisClient>;
    protected loadCommands(): Promise<void>;
    private init;
    disconnect(): Promise<void>;
    reconnect(): Promise<void>;
    close(): Promise<void>;
    private getRedisVersion;
    get redisVersion(): string;
}

export declare type RedisOptions = (RedisOptions_2 | ClusterOptions) & {
    skipVersionCheck?: boolean;
};

export declare function removeAllQueueData(client: RedisClient, queueName: string, prefix?: string): Promise<void | boolean>;

export declare class Repeat extends QueueBase {
    addNextRepeatableJob<T = any, R = any, N extends string = string>(name: N, data: T, opts: JobsOptions, skipCheckExists?: boolean): Promise<Job<T, R, N>>;
    private createNextJob;
    removeRepeatable(name: string, repeat: RepeatOptions, jobId?: string): Promise<void>;
    removeRepeatableByKey(repeatJobKey: string): Promise<void>;
    private keyToData;
    getRepeatableJobs(start?: number, end?: number, asc?: boolean): Promise<{
        key: string;
        name: string;
        id: string;
        endDate: number;
        tz: string;
        cron: string;
        next: number;
    }[]>;
    getRepeatableCount(): Promise<number>;
}

/**
 * Settings for repeatable jobs
 *
 * @see {@link https://docs.bullmq.io/guide/jobs/repeatable}
 */
export declare interface RepeatOptions {
    /**
     * A cron pattern
     */
    cron?: string;
    /**
     * Timezone
     */
    tz?: string;
    /**
     * Start date when the repeat job should start repeating (only with `cron`).
     */
    startDate?: Date | string | number;
    /**
     * End date when the repeat job should stop repeating.
     */
    endDate?: Date | string | number;
    /**
     * Number of times the job should repeat at max.
     */
    limit?: number;
    /**
     * Repeat after this amount of milliseconds
     * (`cron` setting cannot be used together with this setting.)
     */
    every?: number;
    /**
     * Repeated job should start right now
     * ( work only with every settings)
     */
    immediately?: boolean;
    /**
     * The start value for the repeat iteration count.
     */
    count?: number;
    prevMillis?: number;
    offset?: number;
    jobId?: string;
}

/**
 * @see {@link https://docs.bullmq.io/guide/workers/sandboxed-processors}
 */
export declare interface SandboxedJob<T = any, R = any> extends Omit<JobJson, 'data' | 'opts' | 'progress' | 'returnValue'> {
    data: T;
    opts: JobsOptions;
    progress: (() => object | number) | ((value: object | number) => Promise<void>);
    updateProgress: (value: object | number) => Promise<void>;
    log: (row: any) => void;
    returnValue: R;
}

/**
 * @see {@link https://docs.bullmq.io/guide/workers/sandboxed-processors}
 */
export declare type SandboxedJobProcessor<T = any, R = any> = ((job: SandboxedJob<T, R>) => R | PromiseLike<R>) | ((job: SandboxedJob<T, R>, callback: (error: unknown, result: R) => void) => void);

/**
 * Lua script loader with include support
 */
export declare class ScriptLoader {
    /**
     * Map an alias to a path
     */
    private pathMapper;
    private clientScripts;
    /**
     * Cache commands by dir
     */
    private commandCache;
    private rootPath;
    constructor();
    /**
     * Add a script path mapping. Allows includes of the form "<includes>/utils.lua" where `includes` is a user
     * defined path
     * @param name - the name of the mapping. Note: do not include angle brackets
     * @param mappedPath - if a relative path is passed, it's relative to the *caller* of this function.
     * Mapped paths are also accepted, e.g. "~/server/scripts/lua" or "<base>/includes"
     */
    addPathMapping(name: string, mappedPath: string): void;
    /**
     * Resolve the script path considering path mappings
     * @param scriptName - the name of the script
     * @param stack - the include stack, for nicer errors
     */
    resolvePath(scriptName: string, stack?: string[]): string;
    /**
     * Recursively collect all scripts included in a file
     * @param file - the parent file
     * @param cache - a cache for file metadata to increase efficiency. Since a file can be included
     * multiple times, we make sure to load it only once.
     * @param stack - internal stack to prevent circular references
     */
    private resolveDependencies;
    /**
     * Parse a (top-level) lua script
     * @param filename - the full path to the script
     * @param content - the content of the script
     * @param cache - cache
     */
    parseScript(filename: string, content: string, cache?: Map<string, ScriptMetadata>): Promise<ScriptMetadata>;
    /**
     * Construct the final version of a file by interpolating its includes in dependency order.
     * @param file - the file whose content we want to construct
     * @param processed - a cache to keep track of which includes have already been processed
     */
    interpolate(file: ScriptMetadata, processed?: Set<string>): string;
    loadCommand(filename: string, cache?: Map<string, ScriptMetadata>): Promise<Command>;
    /**
     * Load redis lua scripts.
     * The name of the script must have the following format:
     *
     * cmdName-numKeys.lua
     *
     * cmdName must be in camel case format.
     *
     * For example:
     * moveToFinish-3.lua
     *
     */
    loadScripts(dir?: string, cache?: Map<string, ScriptMetadata>): Promise<Command[]>;
    /**
     * Attach all lua scripts in a given directory to a client instance
     * @param client - redis client to attach script to
     * @param pathname - the path to the directory containing the scripts
     */
    load(client: RedisClient, pathname: string): Promise<void>;
    /**
     * Clears the command cache
     */
    clearCache(): void;
}

export declare const scriptLoader: ScriptLoader;

export declare class ScriptLoaderError extends Error {
    readonly path: string;
    /**
     * The include stack
     */
    readonly includes: string[];
    readonly line: number;
    readonly position: number;
    constructor(message: string, path: string, stack?: string[], line?: number, position?: number);
}

/**
 * Script metadata
 */
export declare interface ScriptMetadata {
    /**
     * Name of the script
     */
    name: string;
    numberOfKeys?: number;
    /**
     * The path to the script. For includes, this is the normalized path,
     * whereas it may not be normalized for the top-level parent
     */
    path: string;
    /**
     * The raw script content
     */
    content: string;
    /**
     * A hash of the normalized path for easy replacement in the parent
     */
    token: string;
    /**
     * Metadata on the scripts that this script includes
     */
    includes: ScriptMetadata[];
}

export declare class Scripts {
    static isJobInList(queue: MinimalQueue, listKey: string, jobId: string): Promise<boolean>;
    static addJob(client: RedisClient, queue: MinimalQueue, job: JobJson, opts: JobsOptions, jobId: string, parentOpts?: ParentOpts): Promise<string>;
    static pause(queue: MinimalQueue, pause: boolean): Promise<void>;
    static removeRepeatableArgs(queue: MinimalQueue, repeatJobId: string, repeatJobKey: string): string[];
    static removeRepeatable(queue: MinimalQueue, repeatJobId: string, repeatJobKey: string): Promise<void>;
    static remove(queue: MinimalQueue, jobId: string): Promise<number>;
    static extendLock(queue: MinimalQueue, jobId: string, token: string, duration: number): Promise<number>;
    static updateData<T = any, R = any, N extends string = string>(queue: MinimalQueue, job: Job<T, R, N>, data: T): Promise<void>;
    static updateProgress<T = any, R = any, N extends string = string>(queue: MinimalQueue, job: Job<T, R, N>, progress: number | object): Promise<void>;
    static moveToFinishedArgs<T = any, R = any, N extends string = string>(queue: MinimalQueue, job: Job<T, R, N>, val: any, propVal: FinishedPropValAttribute, shouldRemove: boolean | number | KeepJobs, target: FinishedStatus, token: string, fetchNext?: boolean): string[];
    private static moveToFinished;
    static finishedErrors(code: number, jobId: string, command: string, state?: string): Error;
    static drainArgs(queue: MinimalQueue, delayed: boolean): (string | number)[];
    static drain(queue: MinimalQueue, delayed: boolean): Promise<void>;
    static moveToCompleted<T = any, R = any, N extends string = string>(queue: MinimalQueue, job: Job<T, R, N>, returnvalue: any, removeOnComplete: boolean | number | KeepJobs, token: string, fetchNext: boolean): Promise<JobData | []>;
    static moveToFailedArgs<T = any, R = any, N extends string = string>(queue: MinimalQueue, job: Job<T, R, N>, failedReason: string, removeOnFailed: boolean | number | KeepJobs, token: string, fetchNext?: boolean): string[];
    static isFinished(queue: MinimalQueue, jobId: string, returnValue?: boolean): Promise<number | [number, string]>;
    static getState(queue: MinimalQueue, jobId: string): Promise<JobState | 'unknown'>;
    static changeDelay(queue: MinimalQueue, jobId: string, delay: number): Promise<void>;
    static changeDelayArgs(queue: MinimalQueue, jobId: string, timestamp: number): string[];
    static moveToDelayedArgs(queue: MinimalQueue, jobId: string, timestamp: number): string[];
    static moveToWaitingChildrenArgs(queue: MinimalQueue, jobId: string, token: string, opts?: MoveToChildrenOpts): string[];
    static moveToDelayed(queue: MinimalQueue, jobId: string, timestamp: number): Promise<void>;
    /**
     * Move parent job to waiting-children state.
     *
     * @returns true if job is successfully moved, false if there are pending dependencies.
     * @throws JobNotExist
     * This exception is thrown if jobId is missing.
     * @throws JobLockNotExist
     * This exception is thrown if job lock is missing.
     * @throws JobNotInState
     * This exception is thrown if job is not in active state.
     */
    static moveToWaitingChildren(queue: MinimalQueue, jobId: string, token: string, opts?: MoveToChildrenOpts): Promise<boolean>;
    /**
     * Remove jobs in a specific state.
     *
     * @returns Id jobs from the deleted records.
     */
    static cleanJobsInSet(queue: MinimalQueue, set: string, timestamp: number, limit?: number): Promise<string[]>;
    static retryJobArgs<T = any, R = any, N extends string = string>(queue: MinimalQueue, job: Job<T, R, N>): string[];
    private static retryJobsArgs;
    static retryJobs(queue: MinimalQueue, state?: FinishedStatus, count?: number, timestamp?: number): Promise<number>;
    /**
     * Attempts to reprocess a job
     *
     * @param queue -
     * @param job -
     * @param state - The expected job state. If the job is not found
     * on the provided state, then it's not reprocessed. Supported states: 'failed', 'completed'
     *
     * @returns Returns a promise that evaluates to a return code:
     * 1 means the operation was a success
     * 0 means the job does not exist
     * -1 means the job is currently locked and can't be retried.
     * -2 means the job was not found in the expected set
     */
    static reprocessJob<T = any, R = any, N extends string = string>(queue: MinimalQueue, job: Job<T, R, N>, state: 'failed' | 'completed'): Promise<void>;
    static moveToActive<T, R, N extends string>(worker: Worker<T, R, N>, token: string, jobId?: string): Promise<[] | [number | JobJsonRaw, string?]>;
    /**
     * It checks if the job in the top of the delay set should be moved back to the
     * top of the  wait queue (so that it will be processed as soon as possible)
     */
    static updateDelaySet(queue: MinimalQueue, delayedTimestamp: number): Promise<any>;
    static promote(queue: MinimalQueue, jobId: string): Promise<number>;
    /**
     * Looks for unlocked jobs in the active queue.
     *
     * The job was being worked on, but the worker process died and it failed to renew the lock.
     * We call these jobs 'stalled'. This is the most common case. We resolve these by moving them
     * back to wait to be re-processed. To prevent jobs from cycling endlessly between active and wait,
     * (e.g. if the job handler keeps crashing),
     * we limit the number stalled job recoveries to settings.maxStalledCount.
     */
    static moveStalledJobsToWait(queue: QueueScheduler): Promise<any>;
    static obliterate(queue: MinimalQueue, opts: {
        force: boolean;
        count: number;
    }): Promise<number>;
}

export declare interface Strategies {
    [index: string]: BackoffFunction;
}

export declare type StreamName = string;

export declare type StreamReadRaw = [StreamName, EntryRaw[]][];

/**
 * Keeps track on timers created with setTimeout to help clearTimeout
 * for all timers when no more delayed actions needed
 */
declare class TimerManager {
    private readonly timers;
    /**
     * Creates a new timer and returns its ID.
     *
     * @param name - Readable name for the timer
     * @param delay - Delay in milliseconds
     * @param fn - Callback function that is executed after the timer expires
     */
    setTimer(name: string, delay: number, fn: Function): string;
    clearTimer(id: string): void;
    clearAllTimers(): void;
}

export declare function tryCatch(fn: (...args: any) => any, ctx: any, args: any[]): any;

/**
 * UnrecoverableError
 *
 * Error to move a job to failed even if the attemptsMade
 * are lower than the expected limit.
 *
 */
export declare class UnrecoverableError extends Error {
    constructor(message?: string);
}

/**
 *
 * This class represents a worker that is able to process jobs from the queue.
 * As soon as the class is instantiated it will start processing jobs.
 *
 */
export declare class Worker<DataType = any, ResultType = any, NameType extends string = string> extends QueueBase {
    opts: WorkerOptions;
    private drained;
    private waiting;
    private running;
    private blockTimeout;
    protected processFn: Processor<DataType, ResultType, NameType>;
    private resumeWorker;
    protected paused: Promise<void>;
    private _repeat;
    private childPool;
    protected timerManager: TimerManager;
    private blockingConnection;
    private processing;
    constructor(name: string, processor?: string | Processor<DataType, ResultType, NameType>, opts?: WorkerOptions, Connection?: typeof RedisConnection);
    emit<U extends keyof WorkerListener>(event: U, ...args: Parameters<WorkerListener[U]>): boolean;
    off<U extends keyof WorkerListener>(eventName: U, listener: WorkerListener[U]): this;
    on<U extends keyof WorkerListener>(event: U, listener: WorkerListener[U]): this;
    once<U extends keyof WorkerListener>(event: U, listener: WorkerListener[U]): this;
    protected callProcessJob(job: Job<DataType, ResultType, NameType>, token: string): Promise<ResultType>;
    protected createJob(data: JobJsonRaw, jobId: string): Job<DataType, ResultType, NameType>;
    /**
     *
     * Waits until the worker is ready to start processing jobs.
     * In general only useful when writing tests.
     *
     */
    waitUntilReady(): Promise<RedisClient>;
    get repeat(): Promise<Repeat>;
    run(): Promise<any[]>;
    /**
     * Returns a promise that resolves to the next job in queue.
     * @param token - worker token to be assigned to retrieved job
     * @returns a Job or undefined if no job was available in the queue.
     */
    getNextJob(token: string, { block }?: GetNextJobOptions): Promise<Job<DataType, ResultType, NameType>>;
    protected moveToActive(token: string, jobId?: string): Promise<Job<DataType, ResultType, NameType>>;
    private waitForJob;
    /**
     *
     * This function is exposed only for testing purposes.
     */
    delay(): Promise<void>;
    protected nextJobFromJobData(jobData?: JobJsonRaw | number, jobId?: string): Promise<Job<DataType, ResultType, NameType>>;
    processJob(job: Job<DataType, ResultType, NameType>, token: string): Promise<void | Job<DataType, ResultType, NameType>>;
    /**
     *
     * Pauses the processing of this queue only for this worker.
     */
    pause(doNotWaitActive?: boolean): Promise<void>;
    /**
     *
     * Resumes processing of this worker (if paused).
     */
    resume(): void;
    /**
     *
     * Checks if worker is paused.
     *
     * @returns true if worker is paused, false otherwise.
     */
    isPaused(): boolean;
    /**
     *
     * Checks if worker is currently running.
     *
     * @returns true if worker is running, false otherwise.
     */
    isRunning(): boolean;
    /**
     *
     * Closes the worker and related redis connections.
     *
     * This method waits for current jobs to finalize before returning.
     *
     * @param force - Use force boolean parameter if you do not want to wait for
     * current jobs to be processed.
     *
     * @returns Promise that resolves when the worker has been closed.
     */
    close(force?: boolean): Promise<void>;
    /**
     * Returns a promise that resolves when active jobs are cleared
     *
     * @returns
     */
    private whenCurrentJobsFinished;
    private retryIfFailed;
}

export declare interface WorkerListener {
    /**
     * Listen to 'active' event.
     *
     * This event is triggered when a job enters the 'active' state.
     */
    active: (job: Job, prev: string) => void;
    /**
     * Listen to 'closing' event.
     *
     * This event is triggered when the worker is closed.
     */
    closed: () => void;
    /**
     * Listen to 'closing' event.
     *
     * This event is triggered when the worker is closing.
     */
    closing: (msg: string) => void;
    /**
     * Listen to 'completed' event.
     *
     * This event is triggered when a job has successfully completed.
     */
    completed: (job: Job, result: any, prev: string) => void;
    /**
     * Listen to 'drained' event.
     *
     * This event is triggered when the queue has drained the waiting list.
     * Note that there could still be delayed jobs waiting their timers to expire
     * and this event will still be triggered as long as the waiting list has emptied.
     */
    drained: () => void;
    /**
     * Listen to 'error' event.
     *
     * This event is triggered when an error is throw.
     */
    error: (failedReason: Error) => void;
    /**
     * Listen to 'failed' event.
     *
     * This event is triggered when a job has thrown an exception.
     */
    failed: (job: Job, error: Error, prev: string) => void;
    /**
     * Listen to 'paused' event.
     *
     * This event is triggered when the queue is paused.
     */
    paused: () => void;
    /**
     * Listen to 'progress' event.
     *
     * This event is triggered when a job updates it progress, i.e. the
     * Job##updateProgress() method is called. This is useful to notify
     * progress or any other data from within a processor to the rest of the
     * world.
     */
    progress: (job: Job, progress: number | object) => void;
    /**
     * Listen to 'resumed' event.
     *
     * This event is triggered when the queue is resumed.
     */
    resumed: () => void;
}

export declare interface WorkerOptions extends QueueBaseOptions {
    /**
     * Condition to start processor at instance creation.
     */
    autorun?: boolean;
    /**
     * Amount of jobs that a single worker is allowed to work on
     * in parallel.
     *
     * @see {@link https://docs.bullmq.io/guide/workers/concurrency}
     */
    concurrency?: number;
    /**
     * @see {@link https://docs.bullmq.io/guide/rate-limiting}
     */
    limiter?: RateLimiterOptions;
    skipDelayCheck?: boolean;
    drainDelay?: number;
    lockDuration?: number;
    lockRenewTime?: number;
    runRetryDelay?: number;
    settings?: AdvancedOptions;
}

export { }
